#include "MK64F12.h"
 
// --- Hardware Pin Definitions ---
#define LATCH_PIN   (23) // PTB23
#define CLOCK_PIN   (3)  // PTC3
#define DATA_PIN    (12) // PTC12
#define BUTTON_S1   (3)  // PTB3
#define BUTTON_S2   (10) // PTB10
#define BUTTON_S3   (11) // PTB11
#define BUZZER_PIN  (1)  // PTA1
 
// --- 7-segment Map ---
const uint8_t segment_map[] = {
   0xC0, //0
   0xF9, //1
   0xA4, //2
   0xB0, //3
   0x99, //4
   0x92, //5
   0x82, //6
   0xF8, //7
   0x80, //8
   0x90, //9
   0xFF  // blank
};
const uint8_t digit_select[] = {0xF1,0xF2,0xF4,0xF8};
 
// --- Globals ---
volatile uint32_t ms_ticks = 0;
volatile int buzzer_timer = 0;
volatile int display_buffer[4] = {10,10,10,10};
 
// Countdown Data
int timer_digits[4] = {0,0,0,0};
int cursor = 3;
int is_counting = 0;
int countdown_ms = 1000;
 
// --- Prototypes ---
void init_hardware(void);
void shift_out_data(uint8_t segment_val, uint8_t digit_sel);
void check_buttons(void);
 
//=========================================================
// Main
//=========================================================
int main(void) {
   init_hardware();
   while(1) {
       check_buttons();
   }
}
 
//=========================================================
// Button Handler
//=========================================================
void check_buttons(void) {
   static uint32_t lastPress = 0;
   static int prev_S3 = 1;  // 1 = not pressed, 0 = pressed
 
   if (ms_ticks - lastPress < 150) return;
 
   int now_S3 = (PTB->PDIR & (1<<BUTTON_S3)) ? 1 : 0;
 
   // --- S3 Start / Pause (edge detect) ---
   if (prev_S3 == 1 && now_S3 == 0) {   // ????????????????????
       lastPress = ms_ticks;
       is_counting = !is_counting;  // toggle
       buzzer_timer = 100;
   }
 
   prev_S3 = now_S3;   // update
 
   // --- S1: Move cursor left ---
   if ((PTB->PDIR & (1<<BUTTON_S1)) == 0) {
       lastPress = ms_ticks;
       cursor--;
       if (cursor < 0) cursor = 3;
       buzzer_timer = 50;
   }
 
   // --- S2: Increment time digit ---
   if ((PTB->PDIR & (1<<BUTTON_S2)) == 0) {
       lastPress = ms_ticks;
       timer_digits[cursor]++;
       if (timer_digits[cursor] > 9) timer_digits[cursor] = 0;
       buzzer_timer = 50;
   }
}
 
//=========================================================
// SysTick = 1ms
//=========================================================
void SysTick_Handler(void) {
   ms_ticks++;
 
   // --- Buzzer ---
   if (buzzer_timer > 0) {
       PTA->PCOR |= (1<<BUZZER_PIN);
       buzzer_timer--;
   } else {
       PTA->PSOR |= (1<<BUZZER_PIN);
   }
 
   // --- Countdown ---
   if (is_counting) {
       countdown_ms--;
       if (countdown_ms <= 0) {
           countdown_ms = 1000;
           int total = timer_digits[0]*1000 + timer_digits[1]*100 + timer_digits[2]*10 + timer_digits[3];
           if (total > 0) {
               total--;
               timer_digits[0] = (total / 1000) % 10;
               timer_digits[1] = (total / 100) % 10;
               timer_digits[2] = (total / 10) % 10;
               timer_digits[3] = (total % 10);
           } else {
               is_counting = 0;
               buzzer_timer = 2000; // alarm
           }
       }
   }
 
   // --- Update Display Buffer ---
   for (int i=0; i<4; i++)
       display_buffer[i] = timer_digits[i];
 
   // Cursor blink (when not counting)
   if (!is_counting) {
       if ((ms_ticks / 300) % 2 == 0)
           display_buffer[cursor] = 10; // blank
   }
 
   // --- Multiplex Display ---
   static int idx = 0;
   uint8_t seg = segment_map[(display_buffer[idx]>9)?10:display_buffer[idx]];
   shift_out_data(seg, digit_select[idx]);
   idx = (idx+1) & 3;
}
 
//=========================================================
// Init Hardware
//=========================================================
void init_hardware(void) {
   SIM->SCGC5 |= SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTC_MASK;
 
   // Shift Reg Pins
   PORTB->PCR[LATCH_PIN] = PORT_PCR_MUX(1);
   PTB->PDDR |= (1<<LATCH_PIN);
   PORTC->PCR[CLOCK_PIN] = PORT_PCR_MUX(1);
   PORTC->PCR[DATA_PIN]  = PORT_PCR_MUX(1);
   PTC->PDDR |= (1<<CLOCK_PIN) | (1<<DATA_PIN);
 
   // Buzzer
   PORTA->PCR[BUZZER_PIN] = PORT_PCR_MUX(1);
   PTA->PDDR |= (1<<BUZZER_PIN);
 
   // Buttons
   PORTB->PCR[BUTTON_S1] = PORT_PCR_MUX(1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   PORTB->PCR[BUTTON_S2] = PORT_PCR_MUX(1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   PORTB->PCR[BUTTON_S3] = PORT_PCR_MUX(1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK;
   PTB->PDDR &= ~((1<<BUTTON_S1)|(1<<BUTTON_S2)|(1<<BUTTON_S3));
 
   // SysTick 1ms
   SysTick->LOAD = (20971520/1000) - 1;
   SysTick->VAL = 0;
   SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
}
 
//=========================================================
// Shift Out to 74HC595
//=========================================================
void shift_out_data(uint8_t segment_val, uint8_t digit_sel) {
   PTB->PCOR |= (1<<LATCH_PIN);  // Latch low
 
   // 8 bit segment
   for (uint8_t i=0; i<8; i++) {
       if (segment_val & (0x80>>i)) PTC->PSOR |= (1<<DATA_PIN);
       else PTC->PCOR |= (1<<DATA_PIN);
       PTC->PCOR |= (1<<CLOCK_PIN);
       PTC->PSOR |= (1<<CLOCK_PIN);
   }
 
   // 8 bit digit select
   for (uint8_t j=0; j<8; j++) {
       if (digit_sel & (0x80>>j)) PTC->PSOR |= (1<<DATA_PIN);
       else PTC->PCOR |= (1<<DATA_PIN);
       PTC->PCOR |= (1<<CLOCK_PIN);
       PTC->PSOR |= (1<<CLOCK_PIN);
   }
 
   PTB->PSOR |= (1<<LATCH_PIN);  // Latch high
}